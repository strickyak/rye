package representations

func (macro) JExtra() {
  return struct SU { u0, u1 uintptr }
}

func (macro) JType() {
  return SU
}

func (macro) JArg(a) {
  return a  SU
}

func (macro) JVar(a) {
  return a
}

func (macro) JDeclare(s) {
  var s  SU
  _ = s
  return
}

func (macro) JAdd(a,  b ) {
  if (a.u0) != 1 { Panicf("JAdd a not int: %d, %d", a.u0, a.u1) }
  if (b.u0) != 1 { Panicf("JAdd b not int: %d, %d", b.u0, b.u1) }
  return SU{1, ((a.u1) + (b.u1))}
}

func (macro) JSub(a , b ) {
  if (a.u0) != 1 { Panicf("JAdd not int: %d, %d", a.u0, a.u1) }
  if (b.u0) != 1 { Panicf("JAdd b not int: %d, %d", b.u0, b.u1) }
  return SU{1, ((a.u1) - (b.u1))}
}

func (macro) JLT(a , b ) {
  if (a.u0) != 1 { Panicf("JAdd not int: %d, %d", a.u0, a.u1) }
  if (b.u0) != 1 { Panicf("JAdd b not int: %d, %d", b.u0, b.u1) }
  return ((a.u1) < (b.u1))
}

func (macro) JFromInt(i) {
  return SU{1, uintptr(i)}
}

func (macro) JAsInt(a) {
  if (a.u0) != 1 { Panicf("JAdd not int: %d, %d", a.u0, a.u1) }
  return int64(a.u1)
}

