package representations

func (macro) JType() {
  return (uintptr, uintptr)
}

func (macro) JArg(a) {
  return 1[a] uintptr, 2[a] uintptr
}

func (macro) JVar(a) {
  return 1[a], 2[a]
}

func (macro) JDeclare(s) {
  var 1[s] uintptr
  var 2[s] uintptr
  _ = 1[s]
  _ = 2[s]
  return
}

func (macro) JAdd(a,  b ) {
  if (1[a]) != 1 { Panicf("JAdd a not int: %d, %d", 1[a], 2[a]) }
  if (1[b]) != 1 { Panicf("JAdd b not int: %d, %d", 1[b], 2[b]) }
  return 1, ((2[a]) + (2[b]))
}

func (macro) JSub(a , b ) {
  if (1[a]) != 1 { Panicf("JAdd not int: %d, %d", 1[a], 2[a]) }
  if (1[b]) != 1 { Panicf("JAdd b not int: %d, %d", 1[b], 2[b]) }
  return 1, ((2[a]) - (2[b]))
}

func (macro) JLT(a , b ) {
  if (1[a]) != 1 { Panicf("JAdd not int: %d, %d", 1[a], 2[a]) }
  if (1[b]) != 1 { Panicf("JAdd b not int: %d, %d", 1[b], 2[b]) }
  return ((2[a]) < (2[b]))
}

func (macro) JFromInt(i) {
  return 1, uintptr(i)
}

func (macro) JAsInt(a) {
  if (1[a]) != 1 { Panicf("JAdd not int: %d, %d", 1[a], 2[a]) }
  return int64(2[a])
}

