package representations

func (macro) JExtra() {
  return
}

func (macro) JType() {
  return [2]uintptr
}

func (macro) JArg(a) {
  return a  [2]uintptr
}

func (macro) JVar(a) {
  return a
}

func (macro) JDeclare(s) {
  var s  [2]uintptr
  _ = s
  return
}

func (macro) JAdd(a,  b ) {
  if (a[0]) != 1 { Panicf("JAdd a not int: %d, %d", a[0], a[1]) }
  if (b[0]) != 1 { Panicf("JAdd b not int: %d, %d", b[0], b[1]) }
  return [2]uintptr{1, ((a[1]) + (b[1]))}
}

func (macro) JSub(a , b ) {
  if (a[0]) != 1 { Panicf("JAdd not int: %d, %d", a[0], a[1]) }
  if (b[0]) != 1 { Panicf("JAdd b not int: %d, %d", b[0], b[1]) }
  return [2]uintptr{1, ((a[1]) - (b[1]))}
}

func (macro) JLT(a , b ) {
  if (a[0]) != 1 { Panicf("JAdd not int: %d, %d", a[0], a[1]) }
  if (b[0]) != 1 { Panicf("JAdd b not int: %d, %d", b[0], b[1]) }
  return ((a[1]) < (b[1]))
}

func (macro) JFromInt(i) {
  return [2]uintptr{1, uintptr(i)}
}

func (macro) JAsInt(a) {
  if (a[0]) != 1 { Panicf("JAdd not int: %d, %d", a[0], a[1]) }
  return int64(a[1])
}

