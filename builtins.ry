def len(x):
  native:
    'return Mkint(a_x.Len())'

def repr(x):
  native:
    'return MkStr(a_x.Repr())'

def str(x):
  native:
    'return MkStr(a_x.String())'

def int(x):
  native:
    'return MkInt(a_x.Int())'

def float(x):
  native:
    'return MkFloat(a_x.Float())'

def range(x):
  native:
    'return N_range(a_x)'

def sorted(x):
  native:
    'return N_sorted(a_x)'

def list(x):
  native:
    'return MkList(a_x.List())'

def dict(x):
  native:
    'return MkDictFromPairs(a_x.List())'

def tuple(x):
  native:
    'return MkTuple(a_x.List())'

def bool(x):
  native:
    'return MkBool(a_x.Bool())'

def type(x):
  native:
    'return a_x.Type()'

def byt(x):
  native:
    'return N_byt(a_x)'

def rye_pickle(x):
  native:
    # TODO: let this return byt, to avoid copies.
    'return MkStr(string(Pickle(a_x)))'

def rye_unpickle(x):
  native:
    'return UnPickle(a_x.String())'


class PList(native):
  def LEN():
    native:
      'return Mkint(self.Len())'

class PDict(native):
  def clear():
    native:
      'self.PPP = make(map[string]P)'

  def copy():
    native:
      'z := make(map[string]P)'
      'for k, v := range self.PPP { z[k] = v }'
      'return MkDict(z)'

  def items():
    native:
      'z := make([]P, 0, len(self.PPP))'
      'for k, v := range self.PPP { z = append(z, MkTuple([]P{MkStr(k), v})) }'
      'return MkList(z)'

  #def get(key, default = None):
  #  native:
  #    'k := a_key.String()'
  #    'if z, ok := self.PPP[k]; ok { return z }'
  #    'return a_default'

