from go import strings

def len(x):
  native:
    'return Mkint(a_x.Len())'

def repr(x):
  native:
    'return MkStr(a_x.Repr())'

def str(x):
  native:
    'return MkStr(a_x.String())'

def int(x):
  native:
    'return MkInt(a_x.Int())'

def float(x):
  native:
    'return MkFloat(a_x.Float())'

def range(x):
  native:
    'return N_range(a_x)'

def sorted(x):
  native:
    'return N_sorted(a_x)'

def list(x):
  native:
    'return MkList(a_x.List())'

def dict(x):
  native:
    'return MkDictFromPairs(a_x.List())'

def tuple(x):
  native:
    'return MkTuple(a_x.List())'

def bool(x):
  native:
    'return MkBool(a_x.Bool())'

def type(x):
  native:
    'return a_x.Type()'

def byt(x):
  native:
    'return N_byt(a_x)'

def rye_pickle(x):
  native:
    # TODO: let this return byt, to avoid copies.
    'return MkStr(string(Pickle(a_x)))'

def rye_unpickle(x):
  native:
    'return UnPickle(a_x.String())'


class PList(native):
  def append(x):
    native:
      'self.PP = append(self.PP, a_x)'

  def extend(x):
    native:
      'self.PP = append(self.PP, a_x.List()...)'

  def count(x):
    z = 0
    for e in self:
      if e == x:
        z += 1
    return z

  def index(x):
    i = 0
    for e in self:
      if e == x:
        return i
      i += 1
    raise 'ValueError'

  def remove(x):
    del self[self.index(x)]

  def insert(i, x):
    # Tgetitemslice not supported yet ### self[i:i] = [x]
    z = self[:i] + [x] + self[i:]
    native:
      'self.PP = v_z.List()'

  def pop(i = -1):
    x = self[i]
    del self[i]
    return x

  def reverse():
    n = len(self)
    say n, self
    for i in range(int(n/2)):
      say i, n-i-1, self[i], self[n-i-1]
      self[i], self[n-i-1] = self[n-i-1], self[i]

class PDict(native):
  def clear():
    native:
      'self.PPP = make(map[string]P)'

  def copy():
    native:
      'z := make(map[string]P)'
      'for k, v := range self.PPP { z[k] = v }'
      'return MkDict(z)'

  def items():
    native:
      'z := make([]P, 0, len(self.PPP))'
      'for k, v := range self.PPP { z = append(z, MkTuple([]P{MkStr(k), v})) }'
      'return MkList(z)'

  def get(key, default = None):
    native:
      'k := a_key.String()'
      'if z, ok := self.PPP[k]; ok { return z }'
      'return a_default'

class PStr(native):
  def split(x, n = -1):
    if n < 0:
      native:
        'return MkStrs(i_strings.Split(self.S, a_x.String()))'
    else:
      native:
        'return MkStrs(i_strings.SplitN(self.S, a_x.String(), 1 + int(a_n.Int())))'

  def lower():
    native:
      'return MkStr(i_strings.ToLower(self.S))'

  def title():
    native:
      'return MkStr(i_strings.ToTitle(self.S))'

  def upper():
    native:
      'return MkStr(i_strings.ToUpper(self.S))'

  def endswith(x):
    native:
      'return MkBool(i_strings.HasSuffix(self.S, a_x.String()))'

  def startswith(x):
    native:
      'return MkBool(i_strings.HasPrefix(self.S, a_x.String()))'

  def strip(x):
    native:
      'return MkStr(i_strings.Trim(self.S, a_x.String()))'

  def lstrip(x):
    native:
      'return MkStr(i_strings.TrimLeft(self.S, a_x.String()))'

  def rstrip(x):
    native:
      'return MkStr(i_strings.TrimRight(self.S, a_x.String()))'

  def replace(old, new, count = -1):
    native:
      'return MkStr(i_strings.Replace(self.S, a_old.String(), a_new.String(), int(a_count.Int())))'

  def find(x):
    native:
      'return Mkint(i_strings.Index(self.S, a_x.String()))'

  def rfind(x):
    native:
      'return Mkint(i_strings.LastIndex(self.S, a_x.String()))'

  def index(x):
    z = self.find(x)
    if z < 0:
      raise 'ValueError'
    return z

  def rindex(x):
    z = self.rfind(x)
    if z < 0:
      raise 'ValueError'
    return z

pass
